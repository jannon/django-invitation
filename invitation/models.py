import datetime
from django.db import models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from django.utils.timezone import now
from django.core.urlresolvers import reverse
from django.db import connection

from phonenumber_field.modelfields import PhoneNumberField

from invitation import utils

#TODO: delete once we're sure it's not needed
# if getattr(settings, 'INVITATION_USE_ALLAUTH', False):
#     import re
#     SHA1_RE = re.compile('^[a-f0-9]{40}$')
# else:    
#     from registration.models import SHA1_RE

token_generator = None
if getattr(settings, 'INVITATION_USE_TOKEN', False):
    generator_class = utils.get_token_generator_class()
    token_generator = generator_class()
            
    
class InvitationKeyManager(models.Manager):
    def get_key(self, invitation_key):
        """
        Return InvitationKey, or None if it doesn't (or shouldn't) exist.
        """
        try:
            key = self.get(key=invitation_key)
        except self.model.DoesNotExist:
            return None
        
        return key
        
    def is_key_valid(self, invitation_key):
        """
        Check if an ``InvitationKey`` is valid or not, returning a valid key
        or false.
        """
        invitation_key = self.get_key(invitation_key)
        if invitation_key and invitation_key.is_usable():
            return invitation_key
        return False

    def create_invitation(self, user, 
                          recipient_dict={
                                     InvitationKey.KEY_EMAIL: 'recipient@email.com',
                                     InvitationKey.KEY_FNAME: 'Firstname',
                                     InvitationKey.KEY_LNAME: 'Lastname',
                                     }, save=True):
        """
        Create an ``InvitationKey`` and returns it.
        
        The key for the ``InvitationKey`` is generated by the function
        references byt settings.INVITATION_KEY_GENERATOR.  The default 
        implementation will be a SHA1 hash, generated from a combination of the 
        ``User``'s get_username() and a random salt.
        """
        generate_key = getattr(settings, 'INVITATION_KEY_GENERATOR', utils.get_invitation_key)
        key = generate_key(user)
        if not save:
            return InvitationKey(from_user=user, key='previewkey00000000', date_invited=datetime.datetime.now(), **recipient_dict)
        return self.create(from_user=user, key=key, **recipient_dict)
    
    #TODO: probably something different with 'recipient'
    def create_bulk_invitation(self, user, key, uses, recipient):
        """ Create a set of invitation keys - these can be used by anyone, not just a specific recipient """
        return self.create(from_user=user, key=key, uses_left=uses, recipient=None)

    def remaining_invitations_for_user(self, user):
        """
        Return the number of remaining invitations for a given ``User``.
        """
        invitation_user, created = InvitationUser.objects.get_or_create(
            inviter=user,
            defaults={'invitations_remaining': settings.INVITATIONS_PER_USER})
        return invitation_user.invitations_remaining

    def delete_expired_keys(self):
        for key in self.all():
            if key.key_expired():
                key.delete()


class InvitationKey(models.Model):
    KEY_EMAIL = "recipient_email"
    KEY_FNAME = "recipient_first_name"
    KEY_LNAME = "recipient_last_name"
    KEY_PHONE = "recipient_phone_number"
    KEY_OTHER = "recipient_other"
    
    key = models.CharField(_('invitation key'), max_length=40, db_index=True)
    date_invited = models.DateTimeField(_('date invited'), 
                                        auto_now_add=True)
    from_user = models.ForeignKey(settings.AUTH_USER_MODEL, 
                                  related_name='invitations_sent')
    registrant = models.ManyToManyField(settings.AUTH_USER_MODEL, null=True, blank=True, 
                                  related_name='invitations_used')
    uses_left = models.IntegerField(default=1)
    
    # -1 duration means the key won't expire
    duration = models.IntegerField(default=settings.ACCOUNT_INVITATION_DAYS, null=True, blank=True)
    
    objects = InvitationKeyManager()
    
    recipient_email = models.EmailField(max_length=254, default="", blank=True)
    recipient_first_name = models.CharField(max_length=24, default="", blank=True)
    recipient_last_name = models.CharField(max_length=24, default="", blank=True)
    recipient_phone_number = PhoneNumberField(default="", blank=True)
    recipient_other = models.CharField(max_length=255, default="", blank=True)
    
    def __unicode__(self):
        return u"Invitation from %s on %s (%s)" % (self.from_user.get_username(), self.date_invited, self.key)
    
    def is_usable(self):
        """
        Return whether this key is still valid for registering a new user.        
        """
        return self.uses_left > 0 and not self.key_expired()
    
    def _expiry_date(self):
        # Assumes the duration is positive
        assert self.duration > -1
        expiration_duration = self.duration or settings.ACCOUNT_INVITATION_DAYS
        expiration_date = datetime.timedelta(days=expiration_duration)
        return self.date_invited + expiration_date
    
    def key_expired(self):
        """
        Determine whether this ``InvitationKey`` has expired, returning 
        a boolean -- ``True`` if the key has expired.
        
        The date the key has been created is incremented by the number of days
        specified in the setting ``ACCOUNT_INVITATION_DAYS`` (which should be
        the number of days after invite during which a user is allowed to
        create their account); if the result is less than or equal to the
        current date, the key has expired and this method returns ``True``.

        """
        if self.duration < 0:
            return False
        return self._expiry_date() <= now()
    key_expired.boolean = True
    
    def expiry_date(self):
        if self.duration < 0:
            return _('never')
        return self._expiry_date().strftime('%d %b %Y %H:%M')
    expiry_date.short_description = _('Expiry date')
    
    def mark_used(self, registrant):
        """
        Note that this key has been used to register a new user.
        """
        self.uses_left -= 1
        self.registrant.add(registrant)
        if token_generator:
            token_generator.handle_invitation_used(self)
        self.save()
    
    def get_context(self, extra_context={}):
        site, root_url = utils.get_site()
        invitation_url = root_url + reverse('invitation_invited', kwargs={'invitation_key':self.key})
        exp_date = self.date_invited + datetime.timedelta(days=settings.ACCOUNT_INVITATION_DAYS)
        context = { 'invitation_key': self,
                    'expiration_days': settings.ACCOUNT_INVITATION_DAYS,
                    'from_user': self.from_user,
                    'site': site,
                    'root_url': root_url,
                    'expiration_date': exp_date,
                    'recipient_email': self.recipient_email,
                    'recipient_first_name': self.recipient_first_name,
                    'recipient_last_name': self.recipient_last_name,
                    'recipient_phone_number': self.recipient_phone_number,
                    'recipient_other': self.recipient_other,
                    'token': self.generate_token(invitation_url),
                    'invitation_url':invitation_url}
        context.update(extra_context)
        return context
    
    def generate_token(self, invitation_url):
        if token_generator:
            return token_generator.generate_token(self, invitation_url)
        
        token_html = '<a style="display: inline-block;" href="'+invitation_url+'">' + invitation_url + '</a>'
        return token_html
        
        
class InvitationUser(models.Model):
    inviter = models.ForeignKey(settings.AUTH_USER_MODEL, unique=True)
    invitations_remaining = models.IntegerField()

    def __unicode__(self):
        return u"InvitationUser for %s" % self.inviter.get_username()

    
def user_post_save(sender, instance, created, **kwargs):
    """Create InvitationUser for user when User is created."""
    if created:
        invitation_user = InvitationUser()
        invitation_user.inviter = instance
        invitation_user.invitations_remaining = settings.INVITATIONS_PER_USER
        # prevent error on syncdb when superuser is created
        try:
            invitation_user.save()
        except:
            connection.close()

models.signals.post_save.connect(user_post_save, sender=settings.AUTH_USER_MODEL)

def invitation_key_post_save(sender, instance, created, **kwargs):
    """Decrement invitations_remaining when InvitationKey is created."""
    if created:
        invitation_user = InvitationUser.objects.get(inviter=instance.from_user)
        remaining = invitation_user.invitations_remaining
        invitation_user.invitations_remaining = remaining-1
        invitation_user.save()

models.signals.post_save.connect(invitation_key_post_save, sender=InvitationKey)

def invitation_key_pre_delete(sender, instance, **kwargs):
    if token_generator:
        token_generator.handle_invitation_deleted(instance)

models.signals.post_delete.connect(invitation_key_pre_delete, sender=InvitationKey)
